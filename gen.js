const fs = require('fs')

const NUM_RANKS = 8
const NUM_FILES = 8

const rankLetters = ["1", "2", "3", "4", "5", "6", "7", "8"]
const fileLetters = ["a", "b", "c", "d", "e", "f", "g", "h"]

function writeFile(name, package, content){
    let pcontent = `package ${package}

// generated by gen.js, don't edit
${content}
`

    fs.writeFileSync(`${package}/${name}.go`, pcontent)
}

let sqs = []

for(let rank=0; rank<NUM_RANKS; rank++) for(let file=0; file<NUM_FILES; file++) sqs.push(
    `   Square${fileLetters[file].toUpperCase()}${rankLetters[rank]} = Square(${rank*NUM_RANKS+file})`
)

let ranks = []

for(let rank=0; rank<NUM_RANKS; rank++) ranks.push(
    `   Rank${rankLetters[rank]} = Rank(${rank})`
)

let files = []

for(let file=0; file<NUM_FILES; file++) files.push(
    `   File${fileLetters[file].toUpperCase()} = File(${file})`
)

const square_go = `
const NUM_RANKS = ${NUM_RANKS}
const LAST_RANK = NUM_RANKS - 1
const NUM_FILES = ${NUM_RANKS}
const LAST_FILE = NUM_FILES - 1

const BOARD_AREA = NUM_RANKS * NUM_FILES

const RANK_STORAGE_SIZE_IN_BITS = 3
const FILE_STORAGE_SIZE_IN_BITS = 3

const SQUARE_STORAGE_SIZE_IN_BITS = RANK_STORAGE_SIZE_IN_BITS + FILE_STORAGE_SIZE_IN_BITS

const RANK_SHIFT_IN_BITS = FILE_STORAGE_SIZE_IN_BITS
const FILE_SHIFT_IN_BITS = 0

const RANK_MASK = ((1 << RANK_STORAGE_SIZE_IN_BITS) - 1) << RANK_SHIFT_IN_BITS
const FILE_MASK = (1 << FILE_STORAGE_SIZE_IN_BITS) - 1

type Rank int
type File int
type Square uint

const (
${sqs.join("\n")}
)

const SquareMinValue = SquareA1
const SquareMaxValue = SquareH8

const (
${ranks.join("\n")}
)

const (
${files.join("\n")}
)

var RankLetterOf = [NUM_RANKS]string{${rankLetters.map(rl => `"${rl}"`).join(' , ')}}
var FileLetterOf = [NUM_FILES]string{${fileLetters.map(rl => `"${rl}"`).join(' , ')}}

var UCIOf [BOARD_AREA]string
var UCIToSquare map[string]Square
`

writeFile("square", "basic", square_go)

const figures = [
    ["NoFigure", "."],    
    ["Pawn", "p"],
    ["Knight", "n"],
    ["Bishop", "b"],
    ["Rook", "r"],
    ["Queen", "q"],
    ["King", "k"],
    ["Lancer", "l"],
    ["LancerN", "ln"],
    ["LancerNE", "lne"],
    ["LancerE", "le"],
    ["LancerSE", "lse"],
    ["LancerS", "ls"],
    ["LancerSW", "lsw"],
    ["LancerW", "lw"],
    ["LancerNW", "lnw"],
    ["Sentry", "s"],
    ["Jailer", "j"]
]

const piece_go = `
type Figure int

const (
${figures.map((p,i) => "   " + p[0].padEnd(16, " ") + " = Figure(" + i + ")").join("\n")}
   FigureArraySize  = int(iota)
)

const FigureMinValue = ${figures[1][0]}
const FigureMaxValue = ${figures[figures.length-1][0]}

const LancerMinValue = LancerN
const LancerMaxValue = LancerNW

const LANCER_DIRECTION_MASK = 0b111

// SymbolOf tells the symbol of a Figure
var SymbolOf = [${figures.length}]string{
${figures.map((fig,i) => ('   "' + fig[1] + '"').padEnd(10, " ") + ', // ' + (""+i).padEnd(4, " ") + fig[0]).join("\n")}
}

type Piece int

const (
   NoPiece               = Piece(0)
   DummyPiece            = Piece(1)
${figures.slice(1).map((p,i) =>
    "   " + ("Black"+p[0]).padEnd(21, " ") + " = Piece(" + (2*i + 2) + ")\n" +
    "   " + ("White"+p[0]).padEnd(21, " ") + " = Piece(" + (2*i + 3) + ")"
).join("\n")}
)

const PieceMinValue = Black${figures[1][0]}
const PieceMaxValue = White${figures[figures.length-1][0]}
const PieceArraySize = PieceMaxValue - PieceMinValue + 1

var FigureOf [${figures.length*2}]Figure

type Color int

const (
	Black = Color(iota)
	White
	NoColor
	ColorArraySize = int(iota)
)

const COLOR_MASK = White

const ColorMinValue = 0
const ColorMaxValue = NoColor

func (color Color) Inverse() Color{
    if color == White{
        return Black
    }

    if color == Black{
        return White
    }

    return NoColor
}

// ColorOf tells the color of a Piece
var ColorOf [${figures.length*2}]Color

// ColorFigure constructs a Piece from Color and Figure
var ColorFigure[2][${figures.length}]Piece

// SymbolToPiece tells Piece for a FEN symbol
var SymbolToPiece = map[string]Piece{
${figures.slice(1).map((fig,i) => {
    return  `   "${fig[1]}"`.padEnd(10, " ") + `: Black${fig[0]},`.padEnd(20, " ") + "// " + (i*2+2) + "\n" + 
            `   "${fig[1].substring(0,1).toUpperCase()+fig[1].substring(1)}"`.padEnd(10, " ") + `: White${fig[0]},`.padEnd(20, " ") + "// " + (i*2+3)
}).join("\n")}
}
`

writeFile("piece", "basic", piece_go)

let magicsTxt = fs.readFileSync("magics.txt").toString()

let magics ={
    bishop:[],
    rook:[]
}

for(let line of magicsTxt.split("\n")){
    let m
    if(m=line.match(/^found ([^\s]+)/)){        
        let kind = m[1]
        m = line.match(/for ([^\s]+)/)
        let squareUci = m[1]
        m = line.match(/shift\s+([^\s]+)/)
        let shift = m[1]
        m = line.match(/magic ([^\s]+)/g)
        m = m[1].match(/magic ([^\s]+)/)
        let magic = m[1]
        magics[kind].push({
            squareUci: squareUci,
            shift: shift,
            magic: magic
        })
    }
}

let magics_go = `
import "fmt"

type MagicSquare struct{
    Square  Square
    Shift   int
    Magic   uint64
    Entries []Bitboard
}

func (msq MagicSquare) String() string{
    return fmt.Sprintf("MagicSquare %v %2d %016X %d", msq.Square, msq.Shift, msq.Magic, len(msq.Entries))
}

type Magics [BOARD_AREA]MagicSquare`

for(let kind in magics){
    magics_go += "\n\nvar " + kind.toUpperCase() + "_MAGICS = Magics{\n"
    for(let msq of magics[kind]){
        magics_go += `   {Square${msq.squareUci.toUpperCase()}, ${msq.shift.padStart(3, " ")}, 0x${msq.magic.toLowerCase()}, []Bitboard{}},\n`
    }
    magics_go += "}"
}

writeFile("magics", "basic", magics_go)

